---
layout: post
title: C#笔记
date: 2022-11-29
catalog: true
tags: [C#]
---

# C#笔记

## 程序结构

在`C#`中，程序包含在`namespace`命名空间中，可以使用`using`关键词插入其他命名空间的代码

## 数据类型

`C#`一共包含三种大的数据类型：`值类型`，`引用类型`，`指针类型`

- 值类型直接包含数据，声明时，系统自动分配存储空间存储值
- 引用类型不包含实际数据，包含的是对变量的引用，引用类型具体还包含`object`，`dynamic`，`string`三种
- 指针类型与`C++`中的指针类型用法相似

## 常量

使用`const`关键字定义常量

```c#
const int a;
```

## 运算符

几种特殊的运算符

- `sizeof()`：返回**数据类型**的大小

- `typeof()`：返回`class`的类型

- `is`：判断对象是否为某一类型

- `as`：强制转换类型，转换失败也不会抛出异常

  ```c#
  Object obj = new StringReader("Hello");
  StringReader r = obj as StringReader;
  ```

## 访问修饰符

- `public`：所有对象都可访问
- `private`：对象本身在对象内部可以访问
- `protected`：只有该类对象及其子类对象可以访问
- `internal`：同一个程序集的对象可以访问
- `protected internal`：前两个的并集

## 方法

### 引用传递参数

使用`ref`关键字进行引用传递参数

```c#
public void swap(ref int a,ref int b)
{
    int temp = a;
    a = b;
    b = temp;
}
HelloWord helloWord = new HelloWord();
helloWord.swap(ref a, ref b);
```

### 按输出传递参数

使用`out`关键字来进行输入变量的赋值

可以使用`out`关键字来从函数中返回多个值。传入的`out`参数必须在函数体内为其赋值，其他方面与引用参数相似

```c#
public void swap(out int a,out int b)
{
    a = 1;
    b = 2;
}
HelloWord helloWord = new HelloWord();
helloWord.swap(out a, out b);
```

## 可空类型

### 单问号

使用`?`单问号来对`int`，`double`，`bool`等无法直接赋值为`null`的数据类型进行`null`赋值

```c#
int? a=null;
```

### 双问号

使用`??`双问号合并运算符进行简化操作

```c#
double? num1=null;
double num2=1;
double num3=num1??num2;
```

上面代码中，如果`num1`为空，则`num3`值为`num2`，反之则为`num1`

## 属性

作为一个过渡值，对字段做一个限定

```c#
class HelloWord
{
    private int a;
    public int A
    {
        get{return a;}
        set{if (value < 0){ a = -1;}
            else{a = 1;}}
    ...
    HelloWord helloWord = new HelloWord();
    helloWord.A =-2;
    Console.WriteLine(helloWord.a);
    ...
}
```

## 委托

当需要将方法作为参数传递的时候，就需要用到委托，也就是说，把方法变成一个可引用的对象

定义委托的类型

```c#
delegate void IntMethodInvoker(int x);
```

将方法赋值给委托变量，下面的test是方法名

```c#
IntMethodInvoker invoker=test;
```

这个test方法之后就委托给invoker进行执行了

```c#
int x=invoker(3)
```

### `Action`类型的委托

可以将没有返回值类型的方法赋给`Action`类型的委托，参数类型放在尖括号里

```c#
Action<int> method=test;
```

### `Func`类型的委托

将没有返回值类型的方法赋给`Func`类型的委托，参数和返回值类型放在尖括号里，先放传入参数的类型，最后一个放返回值类型

```c#
Func<int,double,string> func=test;
```

## 匿名方法

当一个方法只会使用一次，代码量不大或者不想定义方法体的时候，可以采用匿名方法

```c#
Func<int,int,int> plus=delegate(int a,int b)
{
    return a+b;
};
```

## `Lambda`表达式

对匿名方法的缩写

```c#
Func<int,int,int> plus=(a,b)=>
{
    return a+b;
};
```

当只有一条语句的时候，还可以省略，有多行语句则需要加上大括号

```c#
Func<int,int,int> plus=(a,b)=>a+b;
```

当只有一个参数的时候，还能省略

```c#
Func<int,int> plus=a=>a*a;
```

当需要用外部变量的时候，可以直接用（一般很少用，因为结果会受到外部参数的影响，容易出错）

```c#
int a=5;
Func<int,int> f=x=>x+a;
```

## 特性

保存程序结构信息的某种特殊类型的类，一般使用中括号放到方法体前面，C#有很多自带特性，也可以使用自定义特性

- 使用`Obsolete`特性将方法标记为弃用

  ```c#
  [Obsolete]
  static void Test()
  {
      
  }
  ```

  还可以添加参数，比如提示信息等

  ```c#
  [Obsolete("这个方法弃用了，请使用最新的NewTest方法")]
  static void Test()
  {
      
  }
  ```

  还可以添加其他参数，以`Obsolete`为例，可以添加第二个参数，表示是否禁止用户调用这个已弃用的方法，在以下情况时，在调用这个方法时，IDE会直接报错

  ```c#
  [Obsolete("这个方法弃用了，请使用最新的NewTest方法"),true]
  static void Test()
  {
      
  }
  ```

- 使用`Conditional`来标记方法能否被调用

  ```c#
          [Conditional("isShow")]
          public static void ShowMessage(string a)
          {
              Console.WriteLine(a);
          }
  ```

  使用宏来决定该方法能否被调用，当`Conditional`中的变量在宏中被定义了的是否，该方法可以被调用，反之亦然

  ```c#
  #define isShow
  ```

- 调用者信息特性

  以`CallerLineNumber`为例，该特性可以获得调用者的行号

  ```c#
          public static void ShowMessege(string a,[CallerLineNumber]int number=0)
          {
              Console.WriteLine(a);
              Console.WriteLine(number);
          }
  ```

  再者，例如`CallerFilePath`特性，该特性可以获得调用者的文件路径

  ```c#
          public static void ShowMessege(string a,[CallerFilePath]string number="")
          {
              Console.WriteLine(a);
              Console.WriteLine(number);
          }
  ```

  ```bash
  D:\VisualStudioProjects\Test\Program.cs
  ```

- 使用`DebuggerStepThrough`特性使得在程序调试时直接跳过此方法

  ```c#
          [DebuggerStepThrough]
          public static void ShowMessege(string a,[CallerFilePath]string number="")
          {
              Console.WriteLine(a);
              Console.WriteLine(number);
          }
  ```


## 多线程

一个应用程序启动，会启动一个进程，然后进程启动多个线程，不同线程完成不同工作

进程包含资源，如Windows句柄，文件系统句柄或其他内核对象

> 句柄指的是访问某些资源的接口

- 使用`Thread`启动线程

  - `Thread`的参数是一个无参无返回值的方法

      ```c#
              private static void show()
              {
                  Console.WriteLine("已启动线程");
              }
      ```

      ```c#
              var t1 = new Thread(show);
              t1.Start();
      ```

  - 代码量不多的时候，也可以传入匿名方法

    ```c#
                var t2 = new Thread((() => {Console.WriteLine("已启动线程："+Thread.CurrentThread.ManagedThreadId);}));
                t2.Start();
    ```

- 向线程中传递参数

  传入线程的带参方法，其参数必须是`Object`类型的

  ```c#
          public static void showHttp(Object o)
          {
              Console.WriteLine(o as string);
          }
  ```

  在启动线程时传入参数

  ```c#
          var t3 = new Thread(showHttp);
          t3.Start("http://www.baidu.com");
  ```

- 后台线程和前台线程

  只有所有前台线程执行完毕后，应用程序的进程才会停止运行

  默认情况下，使用`Thread`创建的线程是前台线程，线程池中的线程是后台线程

  在使用`Thread`创建线程的时候，可以通过设置`IsBackground`属性，表示它是一个前台线程还是后台线程

  ```c#
          var t4=new Thread(show){IsBackground=true};
          t4.Start();
  ```

- 线程的优先级

  当有很多线程需要CPU去执行的时候，CPU通过线程的优先级来判断先去执行哪个线程

  通过线程的`Priority`来设置线程的优先级

  ```c#
          var t4=new Thread(show){IsBackground=true};
  		t4.Priority=ThreadPriority.AboveNormal;
          t4.Start();
  ```

  可以通过线程的`join()`方法，来让当前进程等待该线程执行完再去执行后面的代码

  ```c#
          var t4=new Thread(show){IsBackground=true};
  		t4.Priority=ThreadPriority.AboveNormal;
          t4.Start();
  		t4.join()
          ...
  ```

- 线程池

  系统通过创建线程申请资源需要时间，所以`.NET`会提前创建一些线程放到线程池里，供用户调用

  ```c#
          public static void Download(Object o)
          {
              Console.WriteLine("Downloading..." + Thread.CurrentThread.ManagedThreadId);
          }
  ```
  
  ```c#
          for (int i = 0; i < 5; i++)
          {
              ThreadPool.QueueUserWorkItem(Download);     
          }
  ```
  
  线程池中所有线程都是后台线程，如果进程的所有前台进程都结束了，所有的后台进程就会停止。且不能把入池的线程改为前台进程
  
  不能给入池的线程设置优先级或者名称
  
  入池的线程只能用于时间较短的任务。如果要一直执行，就需要使用`Thread`来创建前台进程
  
- 任务

  - 任务`Task`背后使用的是线程池来实现的，但多核性能远胜于线程池
  
      ```c#
              public static void showTask()
              {
                  Console.WriteLine("已启动任务");
              }
      ```
  
      ```c#
              Task task = new Task(showTask);
              task.Start();
      ```
  
  - 连续任务
  
    使用`ContinueWith`方法把任务的异步变成连续执行
  
    ```c#
            public static void Task1()
            {
                Console.WriteLine("任务1");
            }
    
            public static void Task2(Task t1)
            {
                //传入上一步的任务t1，用于获取相关信息
                Console.WriteLine("任务2");
            }
    ```
  
    ```c#
            Task task1 = new Task(Task1);
            Task task2 = task1.ContinueWith(Task2);
            task1.Start();
    ```
    
  - 解决资源访问冲突问题
  
    先声明一个锁对象
  
    ```c#
            private static Object _lock;
    ```
  
    然后将这个锁对象上锁，其中执行会产生冲突的操作
  
    ```c#
            lock (_Lock)
            {
                Console.WriteLine("1");
            }
    ```
  
  - 解决死锁问题
  
    如果一个线程需要使用的资源被锁住，可能会产生死锁问题
  
    嵌套上锁来解决此问题，保证资源是按顺序锁住的
  

## 文件操作

- `File`

  使用`File`类来对文件进行复制、删除等操作
  
  ```c#
  File.Copy("D:\相关论文\1.pdf","D:\相关论文\2.pdf")
  ```
  
  将文件从一个目录复制到另一个目录

- `Directory`

  使用`Directory`类来对文件夹进行操作

  ```c#
  Directory.CreateDirectory("D:/1");
  ```

  在指定目录创建一个文件夹

- `FileInfo`与`DirectoryInfo`

  可以使用这两个类来将文件和文件夹抽象层类

- `Path`

  使用`Path`类来对路径进行操作，不用管操作系统的环境

  ```c#
  Path.Combine("D:/1", "1.text");
  ```

- `File`

  使用`File`类来进行文件的读写操作

  ```c#
  string fileText = File.ReadAllText("1.txt");
  Console.WriteLine(fileText);
  ```

- 文件流

  当传输的文件尺寸太大无法一次性传输时，就需要建立文件流进行持续传输

  ```c#
  FileStream fileStream = new FileStream("1.txt",FileMode.Append,FileAccess.ReadWrite);
  ```

  附加的两个参数用于指定打开文件的方式以及文件流的读写权限

  ```c#
  FileStream readFileStream = new FileStream("1.txt",FileMode.Open,FileAccess.Read);
  FileStream writeFileStream = new FileStream("2.txt", FileMode.Create, FileAccess.Write);
  int nextByte = -1;
  while ((nextByte=readFileStream.ReadByte())!=-1)
  {
      writeFileStream.WriteByte((byte)nextByte);
  }
  readFileStream.Close();
  writeFileStream.Close();
  ```

  在文件流使用完毕时要进行关闭，采取**先开后关**的原则
  
- 可通过文件缓冲区来加快文件读取

  可根据实际情况以及内存大小来调整缓冲区大小

  ```c#
  int length = 1024;
  byte[] buffer = new byte[length];
  int count = 1;
  while ((count=readFileStream.Read(buffer,0,length))!=0)
  {
      writeFileStream.Write(buffer,0,count);
  }
  readFileStream.Close();
  writeFileStream.Close();
  ```

- 文本文件的读写

  通过`StreamReader`以及`StreamWriter`来对文本文件进行读写，使用这两个类可不考虑文本的编码（当然也可手动指定）

  ```c#
  StreamReader streamReader = new StreamReader("1.txt");
  string line = "";
  while ((line=streamReader.ReadLine())!=null)
  {
      Console.WriteLine(line);
  }
  streamReader.Close();
  ```


## 网络编程

### 服务器端开发

创建一个TCP服务器并配置

```c#
//服务器IP地址以及端口号  
IPAddress ip = IPAddress.Parse("127.0.0.1");
int myProt=500;
//创建一个TCP服务器，参数表示IP地址类型，传输的数据类型，协议类型
serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
//绑定IP地址以及端口  
serverSocket.Bind(new IPEndPoint(ip, myProt));
//允许最多10个客户端连接
serverSocket.Listen(10);      
```

服务器端开始监听并获得连接的客户端对象

```c#
Socket clientSocket = serverSocket.Accept();
```

### 客户端连接服务器

创建客户端

```c#
TcpClient _client=new TcpClient();
```

连接服务器

```c#
_client.Connect("127.0.0.1", portNo)
```

### 客户端发送消息

向服务端发送二进制消息

```c#
this._client.Send(Encoding.UTF8.GetBytes("Hello!"));
```

### 服务端接收消息

在服务端通过获得的客户端对象与服务端通信

```c#
//data存放接收的数据
byte[] data = new byte[1024];
//返回数据长度
int length = myClientSocket.Receive(data);
//将数据转换为string
string message = Encoding.UTF8.GetString(data, 0, length);
```

