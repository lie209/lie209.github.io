---
layout: post
title: WPF 笔记
date: 2022-11-1
catalog: true
tags: [C#]
---

# 几种常见的布局

## Grid

表格布局，定义好表格的行列，在行列块中插入其他元素

## StackPanel

栈式布局，在栈中插入元素，可以选择竖向的栈还是横向的栈

## DockPanel

浮动式布局，按顺序浮动插入元素

## WrapPanel

与`DockPanel`很像，不过是按行来插入元素的，多余的元素会自动换行

# 数据绑定的使用

## UpdateSourceTrigger

三种形式：`Explicit`、`LostFocus`、`PropertyChanged`

### Explicit

绑定数据源后，需要调用事件手动更新

```c#
//获取绑定表达式，也就是绑定的目标和源
var binding=titleTextBox.GetBindingExpression(TextBox.TextProperty);
//更新绑定目标值
binding.UpdateSource();
```

### LostFocus

当前控件失去焦点后更新

### PropertyChanged

数据变更时，绑定的对象实时更新

## INotifyPropertyChanged

类通过实现`INotifyPropertyChanged`接口的方法，来完成当绑定的数据源（比如说某个属性值）变更时，来完成对绑定目标的更新

首先进行目标绑定

```c#
<TextBox Text="{Binding Name}"></TextBox>
<Button Content="更新源" Name="updateUser" Click="UpdateUser_OnClick"> </Button>
```

当前`TextBox`对象的`Text`属性被绑定到了当前`DataContext`的类中的`Name`属性中，当触发按钮点击事件时，需要通知控件，数据源已经更新，于是实现`INotifyPropertyChanged`接口中的方法，并在属性的`set`方法中调用

```c#
...
        private string _name;
        public string Name
        {
            get { return _name;}
            set { 
                _name = value; 
                //向界面发送通知
                OnPropertyChanged((nameof(Name))); 
            }
        }
        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
...
```

>代码中的`nameof()`方法用于返回属性名而不是其中的内容

## ObservableCollection

同上，如果列表元素需要在后台更新后通知控件同步更新，就需要使用`ObservableCollection`列表，并赋值给`ListBox`的`ItemSource`

```c#
...
    private ObservableCollection<User> _list = new ObservableCollection<User>();
...
    lbUser.ItemsSource = _list;
```

这样就实现了前后台列表的同步更新

## IValueConverter

如果需要依赖属性的数据源在赋值之前进行数据转换，就需要实现`IValueConverter`接口

```c#
public class BoolConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        var check = value.ToString().ToLower();
        switch (check)
        {
            case "yes":
                return true;
        }
        return false;
    }
...
```

该接口的`Convert`方法获得绑定源的`value`值后，对`value`进行转换，然后将转换结果返回给绑定目标

在使用时需要先声明转换器作为资源

```c#
...
    <Window.Resources>
        <local:BoolConverter x:Key="BoolConverter"></local:BoolConverter>
    </Window.Resources>
...
```

然后在绑定的时候插入该转换器

```c#
<CheckBox Content="YES" IsChecked="{Binding ElementName=tbConverter,Path=Text,Converter={StaticResource BoolConverter}}" HorizontalAlignment="Center"></CheckBox>
```

即可实现数据的转换

## IDataErrorInfo

绑定数据源通过实现`IDataErrorInfo`接口来实现对数据的绑定校验

在继承`IDataErrorInfo`接口后，实现其中的一个索引属性

```c#
...   
		public string this[string columnName]
        {
            get
            {
                switch (columnName)
                {
                    case "stuName":
                        if(stuName.Length < 4)
                        {
                            return "长度不合要求";
                        } ;
                        break;
                    case "stuScore":
                        if(stuScore > 100)
                        {
                            return "分数非法";
                        } ;
                        break;
                }
                return null;
            }
        }
...
```

然后在窗口的资源内添加类

```c#
<Window.Resources>
        <local:StudentInfo x:Key="StudentInfo"></local:StudentInfo>
    </Window.Resources>
```

在绑定时声明`ValidatesOnDataErrors`启用验证器

```c#
<TextBox Width="100" Margin="10 0 0 0" Text="{Binding stuName,ValidatesOnDataErrors=True,UpdateSourceTrigger=PropertyChanged}"></TextBox>
```

