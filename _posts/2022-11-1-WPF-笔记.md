---
layout: post
title: WPF 笔记
date: 2022-11-7
catalog: true
tags: [C#]
---

> WPF的XAML是一种可视化的操作对象的过程

# 几种常见的布局

## Grid

表格布局，定义好表格的行列，在行列块中插入其他元素

## StackPanel

栈式布局，在栈中插入元素，可以选择竖向的栈还是横向的栈

## DockPanel

浮动式布局，按顺序浮动插入元素

## WrapPanel

与`DockPanel`很像，不过是按行来插入元素的，多余的元素会自动换行

# 依赖属性

## 三步走

- 依赖属性的声明

  ```c#
  //依赖属性命名规则：名称+Property关键字
  public static readonly DependencyProperty MyNameProperty;
  ```

- 依赖属性对应属性的声明，这里的属性是对依赖属性的包装，在WPF中，使用依赖属性，而不是普通的变量

  ```c#
  //依赖属性对应的属性名称
  public string? MyName
  {
      get {return(string?)GetValue(MyNameProperty);}
      set{SetValue(MyNameProperty,value);} 
  }
  ```

- 依赖属性的绑定

  ```c#
  //进行注册是为了性能问题，将依赖属性缓存到一个全局的字典对象中，并设置内容更改时的回调函数
  MyNameProperty = DependencyProperty.Register("MyNameProperty", typeof(string), typeof(MainWindow),new PropertyMetadata( string.Empty,new PropertyChangedCallback(OnMyNamePropertyChanged)));
  ```

# 数据绑定

## 使用对象作为数据源

首先建立一个对象

```c#
    public class Student
    {
        public string Id { get; set; }
        public string Name { get; set; }

        public Student()
        {
            Id = "111";
            Name = "test";
        }
    }
```

将对象放入窗口的资源中

```c#
    <Window.Resources>
        //定义Student类实例，并进行属性的赋值
        <local:Student x:Key="Student" Name="test"></local:Student>
    </Window.Resources>
```

在控件中引入资源

```c#
 <TextBlock Name="Student" Text="{Binding Source={StaticResource Student},Path=Name}"></TextBlock>
```

> 静态资源指的是在运行过程中值就不会变了，如果要变的话就用动态资源声明

## 使用Array作为数据源

声明一个列表资源，注意别忘了指明类型

```c#
        <x:Array x:Key="studentArray" x:Type="local:Student">
            <local:Student Name="Gerry"></local:Student>
            <local:Student Name="Tom"></local:Student>
            <local:Student Name="Jerry"></local:Student>
        </x:Array>
```

在`ListBox`中引用资源

```c#
<ListBox ItemsSource="{StaticResource studentArray}">
    <ListBox.ItemTemplate>
        <DataTemplate>
            <TextBlock Text="{Binding Name}"></TextBlock>
        </DataTemplate>    
    </ListBox.ItemTemplate>
</ListBox>
```

## 相对数据源绑定

> 从当前级别逐步往上搜索的过程，比较耗费时间

设置相对的搜索节点，表示在当前树中搜索`Window`元素，将数据绑定在该元素的`Id`上

```c#
<TextBlock Text="{Binding RelativeSource={RelativeSource AncestorType=Window},Path=Id}"></TextBlock>
```

## 数据上下文方式

在以下代码中，文本框控件初始化的过程中，已经将`Student`对象绑定到了`TextBlock`控件中

```c#
<TextBlock DataContext="{StaticResource Student}" Text="{Binding Path=Id}"></TextBlock>
```

或者在代码中手动指定`DataContext`，将对象作为指定控件的上下文

```c#
<TextBlock Name="tbContext" Text="{Binding Path=Id}"></TextBlock>
```

```c#
tbContext.DataContext = new Student();
```

## 把控件的属性值作为绑定源

指定控件名`ElementName`和路径`Path`，绑定数据

```c#
<TextBlock Name="tbContext" Text="123"></TextBlock>
<TextBlock Text="{Binding ElementName=tbContext,Path=Text}"></TextBlock>
```

## UpdateSourceTrigger

三种形式：`Explicit`、`LostFocus`、`PropertyChanged`

### Explicit

绑定数据源后，需要调用事件手动更新

```c#
//获取绑定表达式，也就是绑定的目标和源
var binding=titleTextBox.GetBindingExpression(TextBox.TextProperty);
//更新绑定目标值
binding.UpdateSource();
```

### LostFocus

当前控件失去焦点后更新

### PropertyChanged

数据变更时，绑定的对象实时更新

## INotifyPropertyChanged

> 使用依赖属性则不需要这样，因为内部已经实现了双向绑定

类通过实现`INotifyPropertyChanged`接口的方法，来完成当绑定的数据源（比如说某个属性值）变更时，来完成对绑定目标的更新

首先进行目标绑定

```c#
<TextBox Text="{Binding Name}"></TextBox>
<Button Content="更新源" Name="updateUser" Click="UpdateUser_OnClick"> </Button>
```

当前`TextBox`对象的`Text`属性被绑定到了当前`DataContext`的类中的`Name`属性中，当触发按钮点击事件时，需要通知控件，数据源已经更新，于是实现`INotifyPropertyChanged`接口中的方法，并在属性的`set`方法中调用

```c#
...
        private string _name;
        public string Name
        {
            get { return _name;}
            set { 
                _name = value; 
                //向界面发送通知
                OnPropertyChanged((nameof(Name))); 
            }
        }
        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
...
```

>代码中的`nameof()`方法用于返回属性名而不是其中的内容

## ObservableCollection

同上，如果列表元素需要在后台更新后通知控件同步更新，就需要使用`ObservableCollection`列表，并赋值给`ListBox`的`ItemSource`

```c#
...
    private ObservableCollection<User> _list = new ObservableCollection<User>();
...
    lbUser.ItemsSource = _list;
```

这样就实现了前后台列表的同步更新

## IValueConverter

如果需要依赖属性的数据源在赋值之前进行数据转换，就需要实现`IValueConverter`接口

```c#
public class BoolConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        var check = value.ToString().ToLower();
        switch (check)
        {
            case "yes":
                return true;
        }
        return false;
    }
...
```

该接口的`Convert`方法获得绑定源的`value`值后，对`value`进行转换，然后将转换结果返回给绑定目标

在使用时需要先声明转换器作为资源

```c#
...
    <Window.Resources>
        <local:BoolConverter x:Key="BoolConverter"></local:BoolConverter>
    </Window.Resources>
...
```

然后在绑定的时候插入该转换器

```c#
<CheckBox Content="YES" IsChecked="{Binding ElementName=tbConverter,Path=Text,Converter={StaticResource BoolConverter}}" HorizontalAlignment="Center"></CheckBox>
```

即可实现数据的转换

## IDataErrorInfo

绑定数据源通过实现`IDataErrorInfo`接口来实现对数据的绑定校验

在继承`IDataErrorInfo`接口后，实现其中的一个索引属性

```c#
...   
		public string this[string columnName]
        {
            get
            {
                switch (columnName)
                {
                    case "stuName":
                        if(stuName.Length < 4)
                        {
                            return "长度不合要求";
                        } ;
                        break;
                    case "stuScore":
                        if(stuScore > 100)
                        {
                            return "分数非法";
                        } ;
                        break;
                }
                return null;
            }
        }
...
```

然后在窗口的资源内添加类

```c#
<Window.Resources>
        <local:StudentInfo x:Key="StudentInfo"></local:StudentInfo>
    </Window.Resources>
```

在绑定时声明`ValidatesOnDataErrors`启用验证器

```c#
<TextBox Width="100" Margin="10 0 0 0" Text="{Binding stuName,ValidatesOnDataErrors=True,UpdateSourceTrigger=PropertyChanged}"></TextBox>
```

