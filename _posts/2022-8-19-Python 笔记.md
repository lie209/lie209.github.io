---
layout:     post
title:      Python  笔记
subtitle:  复习 Python 时的一些思考
date:       2022-08-19
catalog: true
tags: [Python]
---
# Python 笔记

## 基本数据类型

### 元组和列表

```python
tuple=(1,2,3)
list=[1,2,"3"]
```

- 字符串是一种特殊的元组

- 元组和列表类似，元组无法直接修改

- 元组可以索引和切片，可以使用`+`操作符拼接

- 切片时可以使用第三个维度，表示取数的间隔，维度的正负表示取数的方向

  ```python
  d=[i for i in range(10)]
  print(d[::-2])
  ```

  ```python
  [9, 7, 5, 3, 1]
  ```

- 可以嵌套创建列表

### Set（集合）

```
sets={1,2,"3"}
```

- 创建空集合必须使用`set()`
- 集合没有顺序，无法切片和索引

### 字典

```python
dict={1:2,"3":4,5:"6"}
```

- 使用`{}`创建空字典
- `键` : `值` 的集合，`键`使用不可变类型

- 使用推导式创建字典：

  ```python
  keys=["Google", "baidu","Alibaba"]
  values=[1,2,3]
  dic={keys[x]:values[x] for x in range(3)}
  ```

### Python 字符串

#### `f-string`

格式化字符串以 `f`开头，后面跟着字符串，字符串中的表达式用大括号 `{} `包起来，它会将变量或表达式计算后的值替换进去

```python
name="lie209"
print(f'Hello {name}')
```

## 推导式生成元组、列表、字典等

### 语法格式

```python
结果值1 if 判断条件 else 结果2  for 变量名 in 原列表
```

### 示例

```python
a={"Google","Alibaba","Baidu"}

b=[i for i in a if len(i)>5]
c={i:i*2 for i in a}
d={i for i in a}
```

### 注意

元组推导式返回的是生成器对象，还需转换为元组对象

```python
e=(i for i in a)
print(tuple(e))
```

## 注释

使用`"""`写多行注释

```python
"""
多行注释
多行注释
"""
```

## 运算符

### 特有的算术运算符

`**`和`//`表示取平方和向下整除

```python
2**2
5//2
```

### 逻辑运算符

`and`、`or`、`not`：与或非

### 成员运算符

`in`、`not in`：表示集合或序列中是否存在该元素 

### 身份运算符

`is` 、 `is not`：`is`用于判断两个标识符时候指向同一个对象，`is not`反之

> `a is b` 相当于 `id(a)==id(b)`，`id()` 能够获取对象的内存地址

与`==`的区别：用于判断引用变量的**值**是否相等

## 循环

### while 循环

> Python中没有`do...while`循环

```python
while <expr>:
    <statement(s)>
else:
    <additional_statement(s)>
```

### for 循环

```python
for <variable> in <sequence>:
    <statements>
else:
    <statements>
```

### range() 函数

指定范围执行语句，还可以指定步长：

```python
a={"Google","Alibaba","Baidu","Tencent"}
b=[i for i in a]
for i in range(-10,-2,3):
    print(f"第{i}次输出：{b}")
```

### `continue`、`break`、`pass` 语句

`continue`和`break`：跳过此次循环、跳出循环

`pass`：占位语句，不做任何事情

## 迭代器和生成器

### 迭代器

- 迭代器的使用

  > 迭代器只能前进，不能后退

  主要使用`iter()`和`next()`函数

  ```python
  a={"Google","Alibaba","Baidu","Tencent"}
  it=iter(a)
  for i in range(len(a)):
      print(next(it))
  ```

- 创建迭代器

  把一个类作为一个迭代器使用需要在类中实现两个方法 `__iter__()` 与 `__next__()` 

  `__iter__()` 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 `__next__()` 方法并通过 `StopIteration` 异常标识迭代的完成

  `__next__()` 方法会返回下一个迭代器对象

  ```python
  class MyNumbers:
    def __iter__(self):
      self.a = 1
      return self
   
    def __next__(self):
      x = self.a
      self.a += 1
      return x
   
  myclass = MyNumbers()
  myiter = iter(myclass)
   
  print(next(myiter))
  ```

### 生成器

使用`yield` 语句的函数会变成一个生成器，在调用该函数的过程中，执行到`yield`语句时会暂停并保存当前运行信息，返回`yield` 的值，在调用`next()`方法时会从中断位置继续执行，直到再次遇到`yield`语句

```python
import sys
 
def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter > n): 
            return
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成
 
while True:
    try:
        print (next(f), end=" ")
    except StopIteration:
        sys.exit()
```

## 函数

函数代码以`def`开头，函数内容以`:`起始并缩进，以`return`结束

带有默认值的参数必须放在最后面，否则会报错

```python
def printStr(str):
    print(str)

def max(a, b):
    if a>b:
        return a
    else:
        return b

str="Hello, world!"

printStr(str)
print(max(10,20))
```

> Python 中一切都是对象，函数传值严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象

### 对象类型

- 可变类型

  类似 C++ 的引用传递，如 列表，字典。如 `fun(la)`，则是将 la 真正的传过去，修改后 `fun` 外部的 la 也会受影响

- 不可变类型

  类似 C++ 的值传递，如整数、字符串、元组。如 `fun(a)`，传递的只是 a 的值，没有影响 a 对象本身。如果在 `fun(a)` 内部修改 a 的值，则是新生成一个 a 的对象

### 不定长参数

- 加了星号 ***** 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数

  ```python
  def varTuple(*var):
      for i in var:
          print(i,end=" ")
  
  varTuple(1,2,3,4,5,6)
  ```

- 加了两个星号 ***\*** 的参数会以字典的形式导入

  ```python
  def varDic(**var):
      print(f"var:{var}")
  
  varDic(a=1,b=2)
  ```

- 如果单独出现星号 *****，则星号 ***** 后的参数必须用关键字传入

  ```python
  def f(a,b,*,c):
      print(a+b+c)
  
  f(1,2,c=3)
  ```

### 函数多返回值

```python
def mutipleVar():
    a=1
    b=2
    return a,b
print(type(mutipleVar()))
a,b=mutipleVar()
print(f"a:{a},b:{b}")
```

Python 函数返回的多个返回值会自动组合成一个元组

执行结果如下：

```python
<class 'tuple'>
a:1,b:2
```

调用字典变量的 `items()` 方法，会返回 `dict_items` 类型的变量，其包含每个成员都是元组类型的变量。因为返回了多个返回值

```python
a={"Google","Alibaba","Baidu","Tencent"}
b={i:i*2 for i in a}
for i in b.items():
   print(i)
```

```bash
('Baidu', 'BaiduBaidu')
('Google', 'GoogleGoogle')
('Tencent', 'TencentTencent')
('Alibaba', 'AlibabaAlibaba')
```

## Python 模块

> 一个 Python 文件就是一个模块

### 模块的引入

- 方式一

  ```python
  from modules import support
  support.printHello()
  ```

- 方式二

  ```python
  import modules.support
  modules.support.printHello()
  ```

  此时必须要用全名访问

  如果层次太多，可以使用`as`关键字进行重命名，以缩短代码长度，提高可读性

  ```python
  import path1.path2.path3.modname1 as modname
  ```

### \__name__ 属性

一个模块被另一个程序第一次`import`时，其主程序将运行，也就是说整个模块会`run`一次。如果我们想在模块被引入时，仅执行模块中一部分代码，我们可以用`__name__`属性来控制范围

在模块代码中加入：

```python
if __name__=='__main__':
    print("程序自身在运行")
else:
    print("我来自另一模块")
```

### 导入函数、类或者变量

使用 `from package import item` 的形式

```python
from modules.support import printHello
printHello()
```

## 输入和输出

### 格式化输出

使用`str.format()`来格式化输出

```python
for i in range(0,10):
    print("{0:4d}{2:4d}{1:4d}".format(i,i**2,i**3))
```

前面的`0`、`2`、`1`指代`format()`中传入的第几个参数，会依次填充到`{}`中，`:`后面的用于对值更好的美化，比如至少保留这么多的空格

```python
   0   0   0
   1   1   1
   2   8   4
   3  27   9
   ...
```

还可以传入字典等变量

```python
table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print("Google:{0[Google]:2}，Runoob:{0[Runoob]:2}，Taobao:{0[Taobao]:2}".format(table))
```

代码中的`0`指代`format()`函数传入的`table`变量

```python
Google: 1，Runoob: 2，Taobao: 3
```

### 读取键盘输入

使用`input()`内置函数读取键盘输入

```python
str=input("请输入：")
print("输入的值为{0}".format(str))
```

### 读写文件

#### `open(filename, mode)`

两个参数分别为文件路径和打开模式

```python
file=open("txt.txt",'a')
file.write("\nHello World!")
file.close()
```

`a`表示追加写入模式，文件原有内容为：

```
123456789
```

运行代码后的文件内容为：

```
123456789
Hello World!
```

#### `with` 关键字

使用`with`关键字自动关闭`close`文件

```python
with open("txt.txt",'a') as file:
    file.write("\nHello World!")
print(file.closed)
```

#### 序列化对象

使用`pickle`对对象进行序列化

使用`pickle.dumps()`函数或`pickle.loads()`函数将Python对象转换为二进制对象或反向转换

```python
a={"Google","Alibaba","Baidu","Tencent"}
b={i:i*2 for i in a}

c=pickle.dumps(b)
# print(c)

d=pickle.loads(c)
# print(d)
```

使用`pickle.dump()`函数或`pickle.load()`函数将Python对象转换为二进制文件或反向转换

```python
a={"Google","Alibaba","Baidu","Tencent"}
b={i:i*2 for i in a}

with open("bfile.txt",'wb') as bfile:
    pickle.dump(b,bfile)

with open("bfile.txt",'rb') as bfile:
    print(pickle.load(bfile))
```

## 类

### 类的成员

- 变量

  与其他语言不同，Python中类的成员变量可以随意增加和定义

  > 局部变量：定义在函数中的变量，只作用于当前实例的类

  非构造函数中定义的成员变量只对运行过当前函数的实例类有效，例如：

  ```python
  class x:
      def __init__(self):
          pass
      def addx(self):
          self.xa=1
      def x2(self):
          self.xa=self.xa*2
  ```

- 函数

  类的所有函数都必须包含`self`参数，`self` 代表的是类的实例，代表当前对象的地址，而 `self.class` 则指向类

  函数重写，如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法

  ```python
  class x:
      def __init__(self):
          pass
      def printx(self):
          print("class x")
          
  class y(x):
      def __init__(self):
          pass
      def printx(self):
          print("class y")
  
  y=y()
  y.printx()
  ```

### 类的继承

在子类定义时，加上父类名称即可实现类的继承

```
class x:
    def __init__(self):
        pass
        
class y(x):
    def __init__(self):
        pass
```

### \__name__

`__name__`代表程序模块的名称，在自己运行时，`__name__`的值为`__main__`，（一段程序作为主线运行程序时其内置名称就是 `__main__`），在被调用或引入时，`__name__`的值就是其名称

### \__init__() 函数

 类的构造方法，实例化类的时候会自动调用

```python
class x:
    def __init__(self):
        pass
```

### \__call__() 函数

`__call__`作用在于让类能够像对象一样被调用，在`Pytorch`中，`forward()`方法相当于被嵌入到了`__call__`函数中，所以可以直接输入模型获得结果

```python
class x:
    def __init__(self):
        pass
    def __call__(self, a,b):
        print(f"类被当作方法调用，返回和：{a+b}")
x=x()
x(1,2)
```





