---
layout: post
title: MySQL 笔记
date: 2023-9-15
catalog: true
tags: [Java]
---

# MySQL

## 执行一条SQL语句发生了什么

### 连接器

建立连接，管理连接、校验用户身份；

### 查询缓存

查询语句如果命中缓存则直接返回，否则继续向下执行。

MySQL 8.0 已删除该模块

### 解析SQL

通过解析器对SQL查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型

### 执行SQL

- 预处理

  - 检查表或字段是否存在
  - 将`select *`中的`*`符号扩展

- 优化

  基于查询成本的考虑，选择查询成本最小的执行计划

  可使用`explain`来查看执行计划

- 执行

  根据计划执行SQL查询语句，从存储引擎读取记录，返回给客户端

## MySQL 中的一行是怎么存储的

- 表空间（Tablespace）

  包含`段`

- 段（Segment）

  包含`区`

  - 表空间是由多个段组成的。段一般分为数据段、索引段、回滚段等
  - 索引段：存放 B + 树的非叶子节点的区的集合；
  - 数据段：存放 B + 树的叶子节点的区的集合；
  - 回滚段：存放的是回滚数据的区的集合，MVCC 利用了回滚段实现了多版本查询数据。

- 区（Extent）

  包含`页`

  - InnoDB 存储引擎使用 B+ 树来组织数据
  - 为了提高随机 IO 效率，让 B+ 树中的链表相邻的页物理位置也相邻
  - **在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了**

- 页（Page）

  包含`行`

  - InnoDB的数据是按页为单位来读写的

  - 每个页的大小为 16KB，最多能保证 16KB 的连续存储空间
  - 页的类型有很多，数据页、undo 日志页、溢出页等

- 行（row）

### InnoDB 行格式

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png)



#### 记录的额外信息

- 变长字段长度列表

  char 定长，varchar 变长，变长字段实际存储的数据长度不固定

  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A81.png)

  主要记录变长字段的长度分别是多少

- NULL 值列表

  如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。

  - 二进制位的值为`1`时，代表该列的值为NULL
  - 二进制位的值为`0`时，代表该列的值不为NULL

  另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 `0`

- 记录头信息

  记录头信息中包含的内容很多，几个比较重要的：

  - delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1
  - next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便
  - record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

#### 记录的真实数据

- row_id

  如果没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加该字段，**不是必需的**

- trx_id

  事务 id，表示该数据是由哪个事务生成的，**必需字段，占用 6 个字节**

- roll_pointer

  该条记录上一个版本的指针。**必需的，占用 7 个字节**

### varchar(n)中的 n 的最大取值是多少

**保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535**

例如：在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844

其中，65532=65535-2（变长字段字节数列表所占用的字节数）-1（NULL值列表所占用的字节数）

### 行溢出后，MySQL 是怎么处理的

如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中

Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA.png)

Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA2.png)