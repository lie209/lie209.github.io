---
layout: post
title: 计算机网络笔记
date: 2023-6-15
categories: blog
tags: [Java]
description: 
---

# 计算机网络笔记

## 基础

### TCP/IP 分层结构

使用一套通用的网络协议，来实现不同设备上的进程通信

#### 应用层

- 应用不需要关心数据是如何传输的，只需要把数据交给传输层即可

- 应用层只需要专注于为用户提供应用功能，比如 **HTTP、FTP、SMTP、DNS** 等
- 应用层工作在操作系统中的**用户态**，传输层及以下工作在**内核态**

#### 传输层

- 传输层为上一层，即应用层提供网络支持，**作为应用间传输的媒介，帮助实现应用到应用之间的通信**

  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png)

- **`TCP`与`UDP`两种传输协议工作在传输层**

  - TCP 全称叫传输控制协议（*Transmission Control Protocol*），大部分应用使用的都是这个，比如应用层的 HTTP 协议等，相比较于 UDP ，**为了保证数据传输的可靠性**，多了流量控制、超时重传、拥塞控制等功能

  - UDP 相对简单，不保证数据包是否正确到达对方，因此实时性、传输效率都更高。把 TCP 的特性在应用层实现，也可以实现 UDP 的可靠传输

  - 应用传输的数据在非常大，超过`MSS`（ TCP 最大报文段长度）的时候需要分块传输，在 TCP 协议中，这样的块叫做 TCP 段（*TCP Segment*）

    ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png)

- 传输层使用**端口**来区分不同的应用

  传输层的报文中会携带端口号，接收方可以据此识别该报文是发给哪个应用的

#### 网络层

- 网络层负责将数据从一个设备传输到另一个设备，最常使用的协议是 IP 协议（*Internet Protocol*）

  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png)

- IP 协议将传输层的报文再次封装，加上 IP 包头组成 IP 包，如果 IP 包的大小超过 MTU (以太网中一般为1500字节)，就会再次分片

  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

- IPV4协议，IP 地址共四段32位，每段8位

  - IP 地址组成分为两个部分

    - 网络号，标识 IP 地址属于哪个子网
    - 主机号，标识同一子网下的不同主机

  - 通过子网掩码来得到 IP 地址的网络号和主机号

    比如`10.100.122.0/24`，后面的`/24`表示就是 `255.255.255.0` 子网掩码，`255.255.255.0` 二进制是`11111111-11111111-11111111-00000000`，一共 24 个1，为了简化子网掩码的表示，用`/24`代替`255.255.255.0`

    ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg)

    - 子网掩码与 IP 地址进行按位与运算，得到网络号
    - 子网掩码取反后与 IP 地址进行按位与运算，得到主机号

- 寻址过程中，先匹配网络号，再去找对应的主机

  路由器在寻址工作时，先找到目标地址的子网，然后把数据包转发到对应的网络内

  ![IP地址的网络号](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg)

- **IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘**

#### 网络接口层

在网络层生成 IP 头部之后，网络接口层（*Link Layer*）进一步在 IP 头部的前面加上 MAC 头部，封装成数据帧，发送到网络上

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png)

- IP 头部中的接收方 IP 地址表示网络包的目的地，通过该地址判断包要发到哪里，在以太网中，则需要通过 MAC 地址来进行通讯

- MAC 头部是以太网所使用的信息，包含了接收方和发送方的 MAC 地址等信息，通过 ARP 协议获取目的地的 MAC 地址
- 网络接口层为网络层提供**链路级别**的传输服务，负责在以太网，WiFi 这样的底层网络上发送**原始数据包**，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备

#### 总结

- TCP/IP 整体结构图

  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png)

- 每一层的数据封装格式

  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png)

  网络接口层的传输单位是**`帧（frame）`**，IP 层的传输单位是**`包（packet）`**，TCP 层的传输单位是**`段（segment）`**，HTTP 的传输单位则是**`消息或报文（message）`**。但这些名词并没有什么本质的区分，可以统称为数据包

### 从键入网址到网页显示

先看一下网络拓扑模型

![简单的网络模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg)

#### HTTP

> **键入网址后，浏览器第一步先解析 URL**

浏览器通过对 URL 进行解析，生成发送给 Web 服务器的请求信息

URL 元素组成如下所示：

![URL 解析](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg)

所以 URL 实际上是请求服务器里的文件资源

如果没有路径名，则访问根目录下设置的默认文件，比如说`/index.html`或者`/default.html`

> 解析完 URL 之后，浏览器确定了 Web 服务器和文件名，接下来，浏览器将根据这些信息生成 HTTP 请求消息

HTTP 消息格式如下

![HTTP 的消息格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)

#### DNS

生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器，此时通过 DNS 来查询服务器域名对应的 IP 地址

DNS 就是一种专门保存了 Web 服务器域名与 IP 对应关系的服务器 

- 在域名总，越靠右，层级越高，比如说`im.qq.com`，外国人思维与中国人相反，喜欢从小到大来

- 域名中最后其实还有一个点，例如`www.server.com.`，最后一个点代表根域名

- 所以域名的层级关系如下所示

  - 根 DNS 服务器（.）

  - 顶级域 DNS 服务器（.com）

  - 权威 DNS 服务器（server.com）

    叫权威的原因是，下面的域名由他做主，比如说`im.qq.com`、`110.qq.com`

  ![DNS 树状结构](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg)

- 根域 DNS 服务器保存在互联网所有的 DNS 服务器中，任何 DNS 服务器都可以找到并访问根域 DNS 服务器，这样一来，客户端只需要找到一台 DNS 服务器，就可以顺藤摸瓜找到下层的某台目标 DNS 服务器

- DNS 解析过程如图所示

  *只指路不带路*

  ![域名解析的工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)

  当然，不是每一次都需要这么多步骤，浏览器会看自身有没有对这个域名的缓存，有就直接返回，没有则去问操作系统有没有，如果没有，再去 hosts 文件中看，再没有，才会去问本地 DNS 服务器，开始上图中的步骤

#### 协议栈

通过DNS 获取到 IP 后，HTTP 的传输工作将交给操作系统中的协议栈

协议栈内部为分层架构，上层部分会向下面的部分委托工作，下面的部分收到委托工作后会执行

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg)

- **应用程序通过调用 Socket 库，来委托协议栈工作**

- 协议栈上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行数据收发操作

- 协议栈下面部分使用 IP 协议控制网络包收发操作

  在互联网上传输数据时，数据会被切分成数据包，将数据包发送给对方的操作由 IP 负责

- IP 中还包含`ICMP`协议和`ARP`协议

  - ICMP 用于告知网络包传送过程中**产生的错误以及各种控制信息**
  - ARP 用于根据 IP 地址查询相应的以太网 MAC 地址

#### TCP

> HTTP 是基于 TCP 协议传输的

- 三次握手建立连接

  ![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

  - 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。
  - 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
  - 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。
  - 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了。
  - 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。

  > 为了保证双方都有**发送和接收**的能力

- 如果 HTTP 消息太长了，超过`MSS`长度，将拆分数据发送

  ![MTU 与 MSS](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg)

  - `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。

  - `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

  - 数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。

    ![数据包分割](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

- TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 `80`， HTTPS 默认端口号是 `443`）。

  在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。

#### IP

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象

- 在 IP 协议里面需要有**源地址 IP** 和 **目标地址 IP**：
  - 源地址IP，即是客户端输出的 IP 地址
  - 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP

- IP 报文如图

![IP 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/17.jpg)

#### MAC

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**，MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息

![MAC 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg)

- 在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

  一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

  - `0800` ： IP 协议
  - `0806` ： ARP 协议

  > MAC 发送方和接收方如何确认?

  **发送方**的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了

  **接收方**的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址

  所以先得搞清楚应该把包发给谁，这个只要查一下**路由表**就知道了。在路由表中找到相匹配的条目，然后把包发给 `Gateway` 列中的 IP 地址就可以了

- ARP 协议 

  ARP 协议会在以太网中以**广播**的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。

  然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。

  如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了

  ![ARP 广播](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg)

#### 网卡

网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将**数字信息转换为电信号**，才能在网线上传输，也就是说，这才是真正的数据发送过程

负责执行这一操作的是**网卡**，要控制网卡还需要靠**网卡驱动程序**

网卡驱动获取网络包之后，会将其**复制**到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**

![数据包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png)

- 起始帧分界符是一个用来表示包起始位置的标记
- 末尾的 `FCS`（帧校验序列）用来检查包传输过程是否有损坏

最后网卡会将包转为电信号，通过网线发送出去

#### 交换机

交换机的设计是将网络包**原样**转发到目的地

![交换机的 MAC 地址表](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg)

- 广播地址

  以下两个属于广播地址：

  - MAC 地址中的 `FF:FF:FF:FF:FF:FF`
  - IP 地址中的 `255.255.255.255`

## HTTP

### HTTP 常见面试题

#### HTTP 基本概念

- HTTP 是什么

  超文本传输协议

  - 超文本

    不止文字，还可以传输媒体等

  - 传输

    双向协议，两点之间传输，中间允许中转或接力

  - 协议

    两个以上的参与者，一种约定和规范

- HTTP 常见的状态码有哪些

  - 1XX

    提示信息，协议处理中的一种中间状态，用的比较少

  - 2XX

    服务器成功处理了客户端的请求

    - 200 OK 

      一切正常

    - 204 NO CONTENT

      同样也是成功状态码，与`200`的不同之处在于响应头没有 body 数据

    - 206 PARTIAL CONTENT

      用于表示当前的 Body 数据并不是资源的全部，而是其中的一部分

  - 3XX

    需要客户端使用新的 URL 重新发送请求获取资源，也就是**重定向**

    - 301 **Moved Permanently**

      说明请求的资源已经不存在了，需要改用新的 URL 再次访问

    - 302 **Found**

      请求的资源还在，但需要你用另一个 URL 来访问

    - 304 **Not Modified**

      请求的资源没有修改，可以浏览器可以使用本地的缓存

  - 4XX

    报文有误，服务器无法处理

    - 400 **Bad Request**

      报文有误，并没有指明错误

    - 403 **Forbidden**

      服务器禁止访问该资源，请求了不该请求的资源

    - 404 **Not Found**

      没有找到你要的资源

  - 5XX

    服务器处理时出现了内部错误

    - 500  **Internal Server Error**

      笼统的错误码

    - 501 **Not Implemented**

      你请求的东西服务器还没准备好

    - 502 **Bad Gateway**

      服务器作为网关或者代理时返回的错误码，服务器自身正常，访问后端服务器发生了错误

    - 503 **Service Unavailable**

      我正在忙，你稍后重试一下

#### HTTP 常见字段

- host 字段

  指定服务器域名

- Content-Length

  本次返回的数据长度（解决“粘包”问题）

- Connection

  ```htm
  Connection:Keep-Alive
  ```

- Content-Type

  服务器告诉客户端本次数据的格式

- Content-Encoding

  服务器返回的数据使用了什么压缩方法

  ```html
  Content-Encoding:gzip
  ```

  对应的，客户端也可以告诉服务器自己可以接收哪些压缩方法

  ```html
  Accept-Encoding:gzip,deflate
  ```

### GET 和 POST

#### GET 和 POST 有什么区别

- get 的语义是从服务器获取指定的资源（**只读操作**）
- post 的语义是根据请求负荷（报文 body）对指定的资源做出处理（让服务器做处理操作（**新增或提交数据操作**））

#### GET 和 POST 方法都是安全和幂等的吗

- 安全指的是请求方法不会**破坏**服务器上的资源
- 幂等指的是多次执行相同的操作，结果都是**相同**的

因此，根据以上定义，GET 方法就是安全和幂等的（浏览器可以对请求的数据做缓存），POST 就不是，因为 POST 会修改服务器上的资源（不安全），并且多次提交数据会创建多个资源（不幂等），所以浏览器一般不会缓存 POST 请求

### HTTP 缓存技术

#### 有哪些实现方式

对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都**缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。

所以，避免发送 HTTP 请求的方法就是通过**缓存技术**，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。

HTTP 缓存有两种实现方式，分别是**强制缓存和协商缓存**。

#### 什么是强制缓存

浏览器判断缓存是否过期，如果没有过期则直接使用本地缓存，由**浏览器**来决定是否使用缓存

- `Expires`，绝对时间

- `Cache-Control`，相对时间，**优先级高于 Expires**

  具体实现流程：

  - 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
  - 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
  - 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control

#### 什么是协商缓存

当出现`304`状态码的时候，服务端就是**告知浏览器可以使用本地缓存的资源**，这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png)

协商缓存的实现：

- 第一种：请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现，这两个字段的意思是：
  - **响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间**
  - 请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存
- 第二种：请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段，这两个字段的意思是：
  - **响应头部中 `Etag`：唯一标识响应资源**
  - 请求头部中的 `If-None-Match`：**当资源过期时**，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200
- 第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题
- **协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

### HTTP 特性

#### HTTP/1.1 优点有哪些

HTTP 最突出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」

- 简单

  HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛

- 灵活和易于扩展

  HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都**允许开发人员自定义和扩充**

  并且 HTTP 工作在应用层，下层可以随意变化

- 应用广泛和跨平台

#### HTTP/1.1 缺点有哪些

HTTP 协议里有优缺点一体的**双刃剑**，分别是「**无状态**、**明文传输**」，同时还有一大缺点「**不安全**」

- 无状态的双刃剑

  - 优点是服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务

  - 缺点是服务器在完成有前后关联的操作时会十分麻烦

    例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，**每次都要问一遍身份信息**

    > 可以使用`Cookie`技术来解决
    >
    > **在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了**
    >
    > ![Cookie 技术](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/14-cookie%E6%8A%80%E6%9C%AF.png)

- 明文传输的双刃剑

  - 优点是传输过程中的信息，是可方便阅读的
  - 缺点是所有信息都被暴露出来了

- 不安全的缺点

  HTTP 比较严重的缺点就是不安全：

  - 通信使用明文（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**
  - 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**
  - 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**

  HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致

#### HTTP/1.1 的性能如何

HTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式，所以性能的关键就在这**两点**里

- 长连接

  HTTP/1.1 提出了长连接的通信方式，也叫持久连接，好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载

- 管道网络传输

  即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间**

### HTTP 与 HTTPS

#### HTTP 与 HTTPS 有哪些区别

- HTTPS 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议
- HTTPS 在 TCP 三次握手之后还需要进行 SSL/TLS 的握手过程才可进入加密的报文传输过程
- 端口分别是80和443
- HTTPS 协议需要向 CA 申请数字证书，来保证服务器的身份是可信的

#### HTTPS 解决了 HTTP 的哪些问题

- 窃听风险

  信息加密，混合加密实现信息的机密性

- 篡改风险

  校验机制，摘要算法为数据生成指纹，用于校验数据完整性

- 冒充风险

  身份证书，将服务器公钥放到数字证书中，解决冒充风险

#### HTTPS 如何建立连接的？

- SSL/TLS 协议的基本流程：

  - 客户端向服务器索要并验证服务器公钥

  - 双方协商生产**会话密钥**

  - 双方采用**会话密钥**进行加密通信

​	前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。

​	TLS 的「握手阶段」涉及**四次**通信，使用不同的密钥交换算法，TLS 	握手流程也会不一样的，现在常用的密钥交换算法有两种：[RSA 算法 ](https://xiaolincoding.com/network/2_http/https_rsa.html)和 [ECDHE 算法](https://xiaolincoding.com/network/2_http/https_ecdhe.html)

​	基于RSA算法的TLS握手过程：

![HTTPS 连接建立过程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

- TLS 协议建立

  1. ClientHello

     首先，由客户端向服务器发起加密通信请求，也就是 `ClientHello` 请求。

     在这一步，客户端主要向服务器发送以下信息：

     （1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。

     （2）客户端生产的随机数（`Client Random`），后面**用于生成「会话秘钥」条件之一**。

     （3）客户端支持的密码套件列表，如 RSA 加密算法。

  2. ServerHello

     服务器收到客户端请求后，向客户端发出响应，也就是 `SeverHello`。服务器回应的内容有如下内容：

     （1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。

     （2）服务器生产的随机数（`Server Random`），也是后面**用于生产「会话秘钥」条件之一**。

     （3）确认的密码套件列表，如 RSA 加密算法。

     （4）服务器的数字证书。

  3. 客户端回应

     客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

     如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：

     （1）**一个随机数（`pre-master key`）。该随机数会被服务器公钥加密**。

     （2）**加密通信算法改变通知**，表示随后的信息都将用「会话秘钥」加密通信。

     （3）**客户端握手结束通知**，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

     上面第一项的随机数是整个握手阶段的**第三个随机数**，会发给服务端，所以这个随机数客户端和服务端都是一样的。

     服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，**各自生成**本次通信的「会话秘钥」。

  4. 服务器的最后回应

     服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。

     然后，向客户端发送最后的信息：

     （1）**加密通信算法改变通知**，表示随后的信息都将用「会话秘钥」加密通信。

     （2）**服务器握手结束通知**，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

     至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

- 数字证书签发和验证流程：

  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C.png)

  CA 签发证书的过程，如上图左边部分：

  - 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
  - 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
  - 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

  客户端校验服务端的数字证书的过程，如上图右边部分：

  - 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
  - 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
  - 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

#### HTTPS 的应用数据是如何保证完整性的？

TLS 在实现上分为**握手协议**和**记录协议**两层：

- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；
