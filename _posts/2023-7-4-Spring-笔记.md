---
layout: post
title: Spring 笔记
date: 2023-7-4
catalog: true
tags: [Java]
subtitle: 持续更新，持续进步...
---

# Spring 笔记

## Bean

### 基础配置

Spring 默认创建的bean是单例（控制bean的数量，用一次创建一次不好，方便管理可复用的bean）

配置文件中，使用scope修改是否单例

### 实例化

- 提供可访问的构造方法，然后配置

  > Spring创建bean的时候调用的是无参的构造方法
  >
  > private构造方法依旧可以调用（Spring使用反射机制来调用的）

- 工厂模式（了解即可）

  通过static静态工厂return获得对象

  在Bean配置中添加以下语句指定静态工厂中获得bean的方法

   ```xml
   factory-method=”getOrderDao“
   ```

- 实例工厂与FactoryBean

  与静态工厂不同的是，使用工厂的对象来获得对象

  使用实例工厂构造类时，配置文件中需要指定以下属性

  ```xml
  <bean id="userdao" factory-method="getUserDao" factory-bean="userFactory"/>
  ```

  改良版：

  工厂类实现 FactoryBean 接口，例如：

  ```java
  public class UserDaoFactory implements FactoryBean<UserDao>
  {
      @Override
      public UserDao getObject() throws Exception {
          return new UserDaoImpl();
      }
  
      @Override
      public Class<?> getObjectType() {
          return UserDao.class;
      }
      
      //控制取出的Bean是否是单例的
      public boolean isSingleton()
      {
          return true;
      }
  }
  ```

  配置文件中不需指定特定的工厂方法了，直接调用工厂类来获得实例：
  ```xml
  <bean id="userdao" class="Factory.userFactoryBean"/>
  ```


### 生命周期

- 指定初始化和销毁的方法

  假设有这样一个类：

  ```java
  public class BookDaoImpl implements BookDao 
  {
      @Override
      public void save() {
          
      }
      
      public void init()
      {
          
      }
      
      public void destroy()
      {
          
      }
  }
  ```

  可以在配置文件中指定其初始化销毁操作

  ```xml
  "init-method"="init" destroy-method="destroy"
  ```

  或者在类中实现`InitializingBean`以及`DisposableBean`两个接口，Spring会自动关联这两个方法

  在运行结束时不会自动执行destroy销毁方法，需要手动关闭容器才会执行，或者在容器启动时**注册关闭钩子**

- 初始化容器

  1. 创建对象（内存分配）
  2. 执行构造方法
  3. 执行属性注入（set操作）
  4. 执行bean初始化方法

- 使用bean

  执行业务操作

- 关闭/销毁容器

  1. 执行Bean销毁方法

- 容器关闭前触发bean的销毁操作

- 关闭容器方式

  - 手动关闭容器，调用容器接口的close()操作
  - 注册关闭钩子

### 依赖注入方式

- Setter注入

  在Bean字段下指定`property`字段

  ```xml
  <bean ...>
  <property name="bookDao" ref="bookDao" >
  </bean> 
  ```

  对于基本类型的，使用value进行注入

- 构造器注入

  - 标准书写

    类中指定构造方法

    在配置中指定构造方法的参数

    ```xml
    <bean ...>
    <constructor-arg name="bookDao" ref="bookDao"/>
    <constructor-arg name="userDao" ref="userDao"/> 
    </bean> 
    ```

  - 参数适配（了解）

- 自己开发的模块推荐使用setter注入（*实际开发几乎不写构造方法*）

### 自动装配

IOC容器根据所依赖的资源在容器中自动查找并注入到Bean中

自动装配的方式：

- **按类型（常用）**

  ```xml
  <bean ... autowire="byType ">
  </bean> 
  ```

  需要指定setter方法

- 按名称

  同一类型的Bean有多个的时候

  需保证Bean的id与类中的名称一样    

- 按构造方法

- 不启用自动装配

### 数据源对象管理

例如引入了阿里的druid，

首先先引入依赖

```xml
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.1.16</version>
        </dependency>
```

然后在Bean配置文件中配置这个类的实例

通过依赖注入配置类实例的参数

```xml
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
	<property name="driverClassName" value="com.mysql.jdbc.Driver"</property>
    <property name="url" value=" "</property>
    <property name="username" value=" "</property>
    <property name="password" value=" "</property>
</bean>
```

### 加载properties文件

将数据源等参数写到xml配置文件中不合适，可以抽取出来到一个单独的配置文件中

- ![ ](https://s2.loli.net/2023/08/03/3zjHhPnLBat9QiJ.png)

注意点：

- 系统环境变量优先级默认高于配置文件中的值，出现这种情况需要配置一下

- 加载所有配置文件

  ![image-20230803182007508](C:\Users\13039\AppData\Roaming\Typora\typora-user-images\image-20230803182007508.png)

## 容器

### 创建容器 ![image-20230803182514294](https://s2.loli.net/2023/08/03/NL3kbVKYEr5zRiP.png)

了解：BeanFactory接口是所有容器类的顶层接口 

...

### 容器总结

![image-20230803183253578](https://s2.loli.net/2023/08/03/M4EnTy5cRLA3p2e.png)

### Bean相关

![image-20230803183418634](https://s2.loli.net/2023/08/03/gPtYRIpjq6NfzlZ.png)

## 注解开发

### 注解开发定义Bean

- 在类中添加注解

  ```java
  @Component("bookDao")
  public class BookDaoImpl implements BookDao
  {
      @Override
      public void save() {
  
      }
  
      public void init()
      {
  
      }
  
      public void destroy()
      {
  
      }
  }
  ```

- xml文件指定扫描位置

  ![image-20230803184018849](https://s2.loli.net/2023/08/03/QiFwud5hIUMerZk.png)

- 其他注意点

  `Component`注解和`Repository`、`Service`、`Controller`等注解的功能是一样的，只是为了方便理解

### 纯注解开发

- 使用类来替换配置文件

  - 在项目文件夹下新建`config`子文件夹

  - 创建配置类并使用注解标记

    `Configration`设定当前类为配置类

    ```java
    @Configuration
    public class SpringConfig
    {
        
    }
    ```

  - 根据需要添加配置

    使用`ComponetScan`指定扫描路径

    ```java
    @Configuration
    @ComponentScan("com.itheima")
    public class SpringConfig
    {
    
    }
    ```

  - 使用配置类来完成程序操作

    ![image-20230803184923617](https://s2.loli.net/2023/08/03/sdpBzuVONW7EnS2.png)

### Bean管理

- 作用范围

  使用`Scope`控制Bean是否为单例

  ```java
  @Scope("prototype")
  public class BookDaoImpl implements BookDao
  {
      @Override
      public void save() {
  
      }
  ```

- 生命周期

  使用注解来控制类初始化和销毁时的动作

  销毁动作只有在容器关闭时才会执行

  ```java
      @PostConstruct
      public void init()
      {
  
      }
  
      @PreDestroy
      public void destroy()
      {
  
      }
  ```

### 依赖注入

- 按类型装配（使用反射实现，按类型装配）

  ```java
  @Service
  public class BookServiceImpl
  {
      @Autowired
      BookDao bookDao;
  }
  ```

  注意，只有在SpringBean中才能使用自动装配，也就是使用Service等注解修饰的类中

- 按名称注入

  - 指定名称

    ```java
    @Repository("bookDao")
    public class BookDaoImpl implements BookDao
    {
        @Override
        public void save() {
        }
    }
    ```

  - 按名称注入

    ```java
    @Service
    public class BookServiceImpl
    {
        @Autowired
        @Qualifier("bookDao")
        BookDao bookDao;
    }
    ```

  - @Qualifier需要与@Autowired配合使用

- 注意点

  ![image-20230803190803412](https://s2.loli.net/2023/08/03/3NnbVQJ25tpTvqo.png)

- 基本数据类型注入

  - 使用`Value`来注入值类型

    ```java
    @Service
    public class BookServiceImpl
    {
        @Autowired
        @Qualifier("bookDao")
        BookDao bookDao;
        @Value("name")
        private String name;
    }
    ```

  - 使用配置文件中的值

    - 配置类中使用注解指定配置文件位置

      ```java
      @Configuration
      @ComponentScan("com.whut")
      @PropertySource("application.properties")
      public class SpringConfig
      {
      }
      ```

      配置文件内容为

      ```properties
      name=testName
      ```

    - 使用通配符来在类中注入值类型

      ```java
      @Service
      public class BookServiceImpl
      {
          @Autowired
          @Qualifier("bookDao")
          BookDao bookDao;
          @Value("${name}")
          private String name;
      }
      ```

      不能在构造方法中使用@Value注入的值：

      - @Value注入是在bean初始化后才进行的，也就是说需要等所有属性被设置完成后，才会进行@Value的注入
      - 而构造方法的执行时机是在bean实例化完成，属性注入之前。

### 第三方Bean管理

- 第三方Bean管理（有点像工厂模式，通过方法返回对象）

  1. 定义一个方法获得要管理的对象

     ```java
         public DataSource dataSource()
         {
             DruidDataSource ds=new DruidDataSource();
             ds.setDriverClassName("com.mysql.jdbc.Driver");
             return ds;
         }
     ```

  2. 添加注解，表示当前方法的返回值是一个Bean

     ```java
         @Bean
         public DataSource dataSource()
         {
             DruidDataSource ds=new DruidDataSource();
             ds.setDriverClassName("com.mysql.jdbc.Driver");
             return ds;
         }
     ```

  3. 使用Bean对象

     ```java
     DataSource dataSource=ctx.getBean(DataSource.class)
     ```

- 分离到单独的配置类中

  1. 创建对应的类，并注解成配置文件（不注解Configuration也可以）

     ```java
     @Configuration
     public class JdbcConfig
     {
         @Bean
         public DataSource dataSource()
         {
             DruidDataSource ds=new DruidDataSource();
             ds.setDriverClassName("com.mysql.jdbc.Driver");
             return ds;
         }
     }
     ```

  2. 在主要的配置类中导入该配置类

     ```java
     @Configuration
     @ComponentScan("com.whut")
     @PropertySource("application.properties")
     @Import(JdbcConfig.class)
     public class SpringConfig
     {
     }
     ```

### 为第三方Bean注入依赖

值类型直接使用`@Value`注入，**引用类型直接作为方法参数即可，会自动装配**

```java
//@Configuration
public class JdbcConfig
{
    @Value("${name}")
    private String name;
    @Bean
    public DataSource dataSource(BookDao bookDao)
    {
        System.out.println(bookDao.getClass());
        DruidDataSource ds=new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        return ds;
    }
}
```

### 注解总结

![image-20230803195507780](https://s2.loli.net/2023/08/03/AlTUdacuefBWCbO.png)
